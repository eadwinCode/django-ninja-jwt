{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction The Ninja JWT plugin offers JSON Web Token (JWT) authentication for Django Ninja . Designed to handle common JWT use cases, it provides a robust authentication backend with a practical set of default features. Additionally, Ninja JWT is highly extensible, allowing developers to add custom features as needed. Acknowledgments This project utilizes code from SIMPLE JWT to implement JSON Web Token (JWT) for the Django Ninja REST Framework. The SIMPLE JWT license is included in the license folder.","title":"Ninja JWT"},{"location":"#introduction","text":"The Ninja JWT plugin offers JSON Web Token (JWT) authentication for Django Ninja . Designed to handle common JWT use cases, it provides a robust authentication backend with a practical set of default features. Additionally, Ninja JWT is highly extensible, allowing developers to add custom features as needed.","title":"Introduction"},{"location":"#acknowledgments","text":"This project utilizes code from SIMPLE JWT to implement JSON Web Token (JWT) for the Django Ninja REST Framework. The SIMPLE JWT license is included in the license folder.","title":"Acknowledgments"},{"location":"auth_integration/","text":"Ninja JWT uses Django Ninja HttpBearer as a way to authenticate users reaching your api endpoint. Authenticated user can be found in request.user or request.auth Route Authentication\u2014Class Based from ninja_extra import api_controller , route from ninja_jwt.authentication import JWTAuth @api_controller class MyController : @route . get ( '/some-endpoint' , auth = JWTAuth ()) def some_endpoint ( self ): ... Route Authentication\u2014Function Based from ninja import router from ninja_jwt.authentication import JWTAuth router = router ( '' ) @router . get ( '/some-endpoint' , auth = JWTAuth ()) def some_endpoint ( request ): ... Custom Auth Implementation If you wish to use a different implementation of JWTAuth , then you need to inherit from JWTBaseAuthentication . Please read more on Django Ninja - Authentication , if you want to use a different approach that is not bearer . example: from ninja.security import APIKeyHeader from ninja_jwt.authentication import JWTBaseAuthentication from ninja import router class ApiKey ( APIKeyHeader , JWTBaseAuthentication ): param_name = \"X-API-Key\" def authenticate ( self , request , key ): return self . jwt_authenticate ( request , token = key ) header_key = ApiKey () router = router ( '' ) @router . get ( \"/headerkey\" , auth = header_key ) def apikey ( request ): return f \"Token = { request . auth } \" Asynchronous Route Authentication If you are interested in the Asynchronous Route Authentication, there is AsyncJWTAuth class from ninja_extra import api_controller , route from ninja_jwt.authentication import AsyncJWTAuth @api_controller class MyController : @route . get ( '/some-endpoint' , auth = AsyncJWTAuth ()) async def some_endpoint ( self ): ... N:B some_endpoint must be asynchronous. Any endpoint function marked with AsyncJWTAuth must be asynchronous. Warning Asynchronous feature is only available for django version > 3.0","title":"Route Authentication"},{"location":"auth_integration/#route-authenticationclass-based","text":"from ninja_extra import api_controller , route from ninja_jwt.authentication import JWTAuth @api_controller class MyController : @route . get ( '/some-endpoint' , auth = JWTAuth ()) def some_endpoint ( self ): ...","title":"Route Authentication\u2014Class Based"},{"location":"auth_integration/#route-authenticationfunction-based","text":"from ninja import router from ninja_jwt.authentication import JWTAuth router = router ( '' ) @router . get ( '/some-endpoint' , auth = JWTAuth ()) def some_endpoint ( request ): ...","title":"Route Authentication\u2014Function Based"},{"location":"auth_integration/#custom-auth-implementation","text":"If you wish to use a different implementation of JWTAuth , then you need to inherit from JWTBaseAuthentication . Please read more on Django Ninja - Authentication , if you want to use a different approach that is not bearer . example: from ninja.security import APIKeyHeader from ninja_jwt.authentication import JWTBaseAuthentication from ninja import router class ApiKey ( APIKeyHeader , JWTBaseAuthentication ): param_name = \"X-API-Key\" def authenticate ( self , request , key ): return self . jwt_authenticate ( request , token = key ) header_key = ApiKey () router = router ( '' ) @router . get ( \"/headerkey\" , auth = header_key ) def apikey ( request ): return f \"Token = { request . auth } \"","title":"Custom Auth Implementation"},{"location":"auth_integration/#asynchronous-route-authentication","text":"If you are interested in the Asynchronous Route Authentication, there is AsyncJWTAuth class from ninja_extra import api_controller , route from ninja_jwt.authentication import AsyncJWTAuth @api_controller class MyController : @route . get ( '/some-endpoint' , auth = AsyncJWTAuth ()) async def some_endpoint ( self ): ... N:B some_endpoint must be asynchronous. Any endpoint function marked with AsyncJWTAuth must be asynchronous. Warning Asynchronous feature is only available for django version > 3.0","title":"Asynchronous Route Authentication"},{"location":"blacklist_app/","text":"Ninja JWT includes an app that provides token blacklist functionality. To use this app, include it in your list of installed apps in settings.py : # Django project settings.py ... INSTALLED_APPS = ( ... 'ninja_jwt.token_blacklist' , ... ) Also, make sure to run python manage.py migrate to run the app\\'s migrations. If the blacklist app is detected in INSTALLED_APPS , Ninja JWT will add any generated refresh or sliding tokens to a list of outstanding tokens. It will also check that any refresh or sliding token does not appear in a blacklist of tokens before it considers it as valid. The Ninja JWT blacklist app implements its outstanding and blacklisted token lists using two models: OutstandingToken and BlacklistedToken . Model admins are defined for both of these models. To add a token to the blacklist, find its corresponding OutstandingToken record in the admin and use the admin again to create a BlacklistedToken record that points to the OutstandingToken record. Alternatively, you can blacklist a token by creating a BlacklistMixin subclass instance and calling the instance's blacklist method: from ninja_jwt.tokens import RefreshToken token = RefreshToken ( base64_encoded_token_string ) token . blacklist () This will create unique outstanding token and blacklist records for the token's jti claim or whichever claim is specified by the JTI_CLAIM setting. The blacklist app also provides a management command, flushexpiredtokens , which will delete any tokens from the outstanding list and blacklist that have expired. You should set up a cron job on your server or hosting platform which runs this command daily.","title":"Blacklist App"},{"location":"creating_tokens_manually/","text":"Sometimes, you may wish to manually create a token for a user. This could be done as follows: from ninja_jwt.tokens import RefreshToken def get_tokens_for_user ( user ): refresh = RefreshToken . for_user ( user ) return { 'refresh' : str ( refresh ), 'access' : str ( refresh . access_token ), } The above function get_tokens_for_user will return the serialized representations of new refresh and access tokens for the given user. In general, a token for any subclass of ninja_jwt.tokens.Token can be created in this way.","title":"Creating Token Manually"},{"location":"customizing_token_claims/","text":"If you wish to customize the claims contained in web tokens which are generated by the NinjaJWTDefaultController and NinjaJWTSlidingController views, create a subclass for the desired controller as well as a subclass for its corresponding serializer. Here\\'s an example : Info if you are interested in an Asynchronous version of the class, use AsyncNinjaJWTDefaultController and AsyncNinjaJWTSlidingController . Also note, it's only available for Django versions that support asynchronous actions. from ninja_jwt.schema import TokenObtainPairInputSchema from ninja_jwt.controller import TokenObtainPairController from ninja_extra import api_controller , route from ninja import Schema class UserSchema ( Schema ): first_name : str email : str class MyTokenObtainPairOutSchema ( Schema ): refresh : str access : str user : UserSchema class MyTokenObtainPairSchema ( TokenObtainPairInputSchema ): def output_schema ( self ): out_dict = self . get_response_schema_init_kwargs () out_dict . update ( user = UserSchema . from_orm ( self . _user )) return MyTokenObtainPairOutSchema ( ** out_dict ) @api_controller ( '/token' , tags = [ 'Auth' ]) class MyTokenObtainPairController ( TokenObtainPairController ): @route . post ( \"/pair\" , response = MyTokenObtainPairOutSchema , url_name = \"token_obtain_pair\" ) def obtain_token ( self , user_token : MyTokenObtainPairSchema ): return user_token . output_schema () As with the standard controller, you\\'ll also need to include register the controller as shown in getting_started Use Django Ninja Router If you are interested in using functions rather than classes, then you are also covered. Here is an example from ninja_jwt.routers.blacklist import blacklist_router from ninja_jwt.routers.obtain import obtain_pair_router , sliding_router from ninja_jwt.routers.verify import verify_router Register the router to the django-ninja api like so: from ninja import NinjaAPI api = NinjaAPI () api . add_router ( '/token' , tags = [ 'Auth' ], router = obtain_pair_router ) ... If you are interested in customize the token claims, you can do so by creating a subclass of TokenObtainPairInputSchema and TokenObtainPairController . See Controller Schema Swapping Also, its important to note that NinjaExtra registers a handler for APIException class which is not available in NinjaAPI instance. To fix that, you need the extra code below: from ninja import NinjaAPI from ninja_extra import exceptions api = NinjaAPI () api . add_router ( '' , tags = [ 'Auth' ], router = router ) def api_exception_handler ( request , exc ): headers = {} if isinstance ( exc . detail , ( list , dict )): data = exc . detail else : data = { \"detail\" : exc . detail } response = api . create_response ( request , data , status = exc . status_code ) for k , v in headers . items (): response . setdefault ( k , v ) return response api . exception_handler ( exceptions . APIException )( api_exception_handler ) Controller Schema Swapping You can now swap controller schema in NINJA_JWT settings without having to inherit or override Ninja JWT controller function. All controller input schema must inherit from ninja_jwt.schema.InputSchemaMixin and token generating schema should inherit from ninja_jwt.schema.TokenObtainInputSchemaBase or ninja_jwt.schema.TokenInputSchemaMixin if you want to have more control. Using the example above: # project/schema.py from typing import Type , Dict from ninja_jwt.schema import TokenObtainInputSchemaBase from ninja import Schema from ninja_jwt.tokens import RefreshToken class UserSchema ( Schema ): first_name : str email : str class MyTokenObtainPairOutSchema ( Schema ): refresh : str access : str user : UserSchema class MyTokenObtainPairInputSchema ( TokenObtainInputSchemaBase ): @classmethod def get_response_schema ( cls ) -> Type [ Schema ]: return MyTokenObtainPairOutSchema @classmethod def get_token ( cls , user ) -> Dict : values = {} refresh = RefreshToken . for_user ( user ) values [ \"refresh\" ] = str ( refresh ) values [ \"access\" ] = str ( refresh . access_token ) values . update ( user = UserSchema . from_orm ( user )) # this will be needed when creating output schema return values In the MyTokenObtainPairInputSchema we override get_token to define our token and some data needed for our output schema. We also override get_response_schema to define our output schema MyTokenObtainPairOutSchema . Next, we apply the MyTokenObtainPairInputSchema schema to controller. This is simply done in NINJA_JWT settings. # project/settings.py NINJA_JWT = { 'TOKEN_OBTAIN_PAIR_INPUT_SCHEMA' : 'project.schema.MyTokenObtainPairInputSchema' , } Other swappable schemas can be follow as shown below: # project/settings.py NINJA_JWT = { # FOR OBTAIN PAIR 'TOKEN_OBTAIN_PAIR_INPUT_SCHEMA' : \"project.schema.MyTokenObtainPairInputSchema\" , 'TOKEN_OBTAIN_PAIR_REFRESH_INPUT_SCHEMA' : \"for.obtain_pair.refresh_input.schema\" , # FOR SLIDING TOKEN 'TOKEN_OBTAIN_SLIDING_INPUT_SCHEMA' : \"for.obtain_sliding.input.schema\" , 'TOKEN_OBTAIN_SLIDING_REFRESH_INPUT_SCHEMA' : \"for.obtain_pair.refresh_input.schema\" , 'TOKEN_BLACKLIST_INPUT_SCHEMA' : \"for.blacklist_input.schema\" , 'TOKEN_VERIFY_INPUT_SCHEMA' : \"for.verify_input.schema\" , } Note Controller Schema Swapping is only available from v5.2.4","title":"Customizing Token Claims"},{"location":"customizing_token_claims/#use-django-ninja-router","text":"If you are interested in using functions rather than classes, then you are also covered. Here is an example from ninja_jwt.routers.blacklist import blacklist_router from ninja_jwt.routers.obtain import obtain_pair_router , sliding_router from ninja_jwt.routers.verify import verify_router Register the router to the django-ninja api like so: from ninja import NinjaAPI api = NinjaAPI () api . add_router ( '/token' , tags = [ 'Auth' ], router = obtain_pair_router ) ... If you are interested in customize the token claims, you can do so by creating a subclass of TokenObtainPairInputSchema and TokenObtainPairController . See Controller Schema Swapping Also, its important to note that NinjaExtra registers a handler for APIException class which is not available in NinjaAPI instance. To fix that, you need the extra code below: from ninja import NinjaAPI from ninja_extra import exceptions api = NinjaAPI () api . add_router ( '' , tags = [ 'Auth' ], router = router ) def api_exception_handler ( request , exc ): headers = {} if isinstance ( exc . detail , ( list , dict )): data = exc . detail else : data = { \"detail\" : exc . detail } response = api . create_response ( request , data , status = exc . status_code ) for k , v in headers . items (): response . setdefault ( k , v ) return response api . exception_handler ( exceptions . APIException )( api_exception_handler )","title":"Use Django Ninja Router"},{"location":"customizing_token_claims/#controller-schema-swapping","text":"You can now swap controller schema in NINJA_JWT settings without having to inherit or override Ninja JWT controller function. All controller input schema must inherit from ninja_jwt.schema.InputSchemaMixin and token generating schema should inherit from ninja_jwt.schema.TokenObtainInputSchemaBase or ninja_jwt.schema.TokenInputSchemaMixin if you want to have more control. Using the example above: # project/schema.py from typing import Type , Dict from ninja_jwt.schema import TokenObtainInputSchemaBase from ninja import Schema from ninja_jwt.tokens import RefreshToken class UserSchema ( Schema ): first_name : str email : str class MyTokenObtainPairOutSchema ( Schema ): refresh : str access : str user : UserSchema class MyTokenObtainPairInputSchema ( TokenObtainInputSchemaBase ): @classmethod def get_response_schema ( cls ) -> Type [ Schema ]: return MyTokenObtainPairOutSchema @classmethod def get_token ( cls , user ) -> Dict : values = {} refresh = RefreshToken . for_user ( user ) values [ \"refresh\" ] = str ( refresh ) values [ \"access\" ] = str ( refresh . access_token ) values . update ( user = UserSchema . from_orm ( user )) # this will be needed when creating output schema return values In the MyTokenObtainPairInputSchema we override get_token to define our token and some data needed for our output schema. We also override get_response_schema to define our output schema MyTokenObtainPairOutSchema . Next, we apply the MyTokenObtainPairInputSchema schema to controller. This is simply done in NINJA_JWT settings. # project/settings.py NINJA_JWT = { 'TOKEN_OBTAIN_PAIR_INPUT_SCHEMA' : 'project.schema.MyTokenObtainPairInputSchema' , } Other swappable schemas can be follow as shown below: # project/settings.py NINJA_JWT = { # FOR OBTAIN PAIR 'TOKEN_OBTAIN_PAIR_INPUT_SCHEMA' : \"project.schema.MyTokenObtainPairInputSchema\" , 'TOKEN_OBTAIN_PAIR_REFRESH_INPUT_SCHEMA' : \"for.obtain_pair.refresh_input.schema\" , # FOR SLIDING TOKEN 'TOKEN_OBTAIN_SLIDING_INPUT_SCHEMA' : \"for.obtain_sliding.input.schema\" , 'TOKEN_OBTAIN_SLIDING_REFRESH_INPUT_SCHEMA' : \"for.obtain_pair.refresh_input.schema\" , 'TOKEN_BLACKLIST_INPUT_SCHEMA' : \"for.blacklist_input.schema\" , 'TOKEN_VERIFY_INPUT_SCHEMA' : \"for.verify_input.schema\" , } Note Controller Schema Swapping is only available from v5.2.4","title":"Controller Schema Swapping"},{"location":"development_and_contributing/","text":"To do development work for Ninja JWT, make your own fork on Github, clone it locally, make and activate a virtualenv for it, then from within the project directory: After that, install flit $( venv ) pip install flit Install development libraries and pre-commit hooks for code linting and styles $( venv ) make install To run the tests: $( venv ) make test To run the tests with coverage: $( venv ) make test-cov","title":"Development and Contributing"},{"location":"getting_started/","text":"Requirements Python >= 3.6 Django >= 2.1 Django-Ninja >= 0.16.1 Django-Ninja-Extra >= 0.11.0 These are the officially supported python and package versions. Other versions will probably work. You 're free to modify the tox config and see what is possible. Installation Ninja JWT can be installed with pip: pip install django-ninja-jwt Also, you need to register NinjaJWTDefaultController controller to your Django-Ninja api. The NinjaJWTDefaultController comes with three routes obtain_token , refresh_token and verify_token from ninja_jwt.controller import NinjaJWTDefaultController from ninja_extra import NinjaExtraAPI api = NinjaExtraAPI () api . register_controllers ( NinjaJWTDefaultController ) The NinjaJWTDefaultController comes with three routes obtain_token , refresh_token and verify_token . It is a combination of two subclass TokenVerificationController and TokenObtainPairController . If you wish to customize these routes, you can inherit from these controllers and change its implementation from ninja_extra import api_controller from ninja_jwt.controller import TokenObtainPairController @api_controller ( 'token' , tags = [ 'Auth' ]) class MyCustomController ( TokenObtainPairController ): \"\"\"obtain_token and refresh_token only\" ... api.register_controllers(MyCustomController) If you wish to use localizations/translations, simply add ninja_jwt to INSTALLED_APPS . INSTALLED_APPS = [ ... 'ninja_jwt' , ... ] Using Ninja Router If you prefer not to follow the NinjaExtra methodology, refer to this documentation on how to use Ninja-JWT with Django-Ninja Router . Usage To verify that Ninja JWT is working, you can use curl to issue a couple of test requests: curl \\ -X POST \\ -H \"Content-Type: application/json\" \\ -d '{\"username\": \"davidattenborough\", \"password\": \"boatymcboatface\"}' \\ http://localhost:8000/api/token/pair ... { \"access\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX3BrIjoxLCJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiY29sZF9zdHVmZiI6IuKYgyIsImV4cCI6MTIzNDU2LCJqdGkiOiJmZDJmOWQ1ZTFhN2M0MmU4OTQ5MzVlMzYyYmNhOGJjYSJ9.NHlztMGER7UADHZJlxNG0WSi22a2KaYSfd1S-AuT7lU\", \"refresh\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX3BrIjoxLCJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImNvbGRfc3R1ZmYiOiLimIMiLCJleHAiOjIzNDU2NywianRpIjoiZGUxMmY0ZTY3MDY4NDI3ODg5ZjE1YWMyNzcwZGEwNTEifQ.aEoAYkSJjoWH1boshQAaTkf8G3yn0kapko6HFRt7Rh4\" } You can use the returned access token to prove authentication for a protected view: curl \\ -H \"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX3BrIjoxLCJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiY29sZF9zdHVmZiI6IuKYgyIsImV4cCI6MTIzNDU2LCJqdGkiOiJmZDJmOWQ1ZTFhN2M0MmU4OTQ5MzVlMzYyYmNhOGJjYSJ9.NHlztMGER7UADHZJlxNG0WSi22a2KaYSfd1S-AuT7lU\" \\ http://localhost:8000/api/some-protected-view/ When this short-lived access token expires, you can use the longer-lived refresh token to obtain another access token: curl \\ -X POST \\ -H \"Content-Type: application/json\" \\ -d '{\"refresh\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX3BrIjoxLCJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImNvbGRfc3R1ZmYiOiLimIMiLCJleHAiOjIzNDU2NywianRpIjoiZGUxMmY0ZTY3MDY4NDI3ODg5ZjE1YWMyNzcwZGEwNTEifQ.aEoAYkSJjoWH1boshQAaTkf8G3yn0kapko6HFRt7Rh4\"}' \\ http://localhost:8000/api/token/refresh/ ... {\"access\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX3BrIjoxLCJ0b2tlbl90eXBlIjoiYWNjZX...\", \"refresh\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX3BrIjoxLCJ0b2tlbl90eXBlIjoicmVm...\"} Cryptographic Dependencies (Optional) If you are planning on encoding or decoding tokens using certain digital signature algorithms (i.e. RSA and ECDSA; visit PyJWT for other algorithms), you will need to install the cryptography_ library. This can be installed explicitly, or as a required extra in the django-ninja-jwt requirement: pip install django - ninja - jwt [ crypto ] The django-ninja-jwt[crypto] format is recommended in requirement files in projects using Ninja JWT , as a separate cryptography requirement line may later be mistaken for an unused requirement and removed. cryptography","title":"Getting Started"},{"location":"getting_started/#requirements","text":"Python >= 3.6 Django >= 2.1 Django-Ninja >= 0.16.1 Django-Ninja-Extra >= 0.11.0 These are the officially supported python and package versions. Other versions will probably work. You 're free to modify the tox config and see what is possible.","title":"Requirements"},{"location":"getting_started/#installation","text":"Ninja JWT can be installed with pip: pip install django-ninja-jwt Also, you need to register NinjaJWTDefaultController controller to your Django-Ninja api. The NinjaJWTDefaultController comes with three routes obtain_token , refresh_token and verify_token from ninja_jwt.controller import NinjaJWTDefaultController from ninja_extra import NinjaExtraAPI api = NinjaExtraAPI () api . register_controllers ( NinjaJWTDefaultController ) The NinjaJWTDefaultController comes with three routes obtain_token , refresh_token and verify_token . It is a combination of two subclass TokenVerificationController and TokenObtainPairController . If you wish to customize these routes, you can inherit from these controllers and change its implementation from ninja_extra import api_controller from ninja_jwt.controller import TokenObtainPairController @api_controller ( 'token' , tags = [ 'Auth' ]) class MyCustomController ( TokenObtainPairController ): \"\"\"obtain_token and refresh_token only\" ... api.register_controllers(MyCustomController) If you wish to use localizations/translations, simply add ninja_jwt to INSTALLED_APPS . INSTALLED_APPS = [ ... 'ninja_jwt' , ... ]","title":"Installation"},{"location":"getting_started/#using-ninja-router","text":"If you prefer not to follow the NinjaExtra methodology, refer to this documentation on how to use Ninja-JWT with Django-Ninja Router .","title":"Using Ninja Router"},{"location":"getting_started/#usage","text":"To verify that Ninja JWT is working, you can use curl to issue a couple of test requests: curl \\ -X POST \\ -H \"Content-Type: application/json\" \\ -d '{\"username\": \"davidattenborough\", \"password\": \"boatymcboatface\"}' \\ http://localhost:8000/api/token/pair ... { \"access\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX3BrIjoxLCJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiY29sZF9zdHVmZiI6IuKYgyIsImV4cCI6MTIzNDU2LCJqdGkiOiJmZDJmOWQ1ZTFhN2M0MmU4OTQ5MzVlMzYyYmNhOGJjYSJ9.NHlztMGER7UADHZJlxNG0WSi22a2KaYSfd1S-AuT7lU\", \"refresh\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX3BrIjoxLCJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImNvbGRfc3R1ZmYiOiLimIMiLCJleHAiOjIzNDU2NywianRpIjoiZGUxMmY0ZTY3MDY4NDI3ODg5ZjE1YWMyNzcwZGEwNTEifQ.aEoAYkSJjoWH1boshQAaTkf8G3yn0kapko6HFRt7Rh4\" } You can use the returned access token to prove authentication for a protected view: curl \\ -H \"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX3BrIjoxLCJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiY29sZF9zdHVmZiI6IuKYgyIsImV4cCI6MTIzNDU2LCJqdGkiOiJmZDJmOWQ1ZTFhN2M0MmU4OTQ5MzVlMzYyYmNhOGJjYSJ9.NHlztMGER7UADHZJlxNG0WSi22a2KaYSfd1S-AuT7lU\" \\ http://localhost:8000/api/some-protected-view/ When this short-lived access token expires, you can use the longer-lived refresh token to obtain another access token: curl \\ -X POST \\ -H \"Content-Type: application/json\" \\ -d '{\"refresh\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX3BrIjoxLCJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImNvbGRfc3R1ZmYiOiLimIMiLCJleHAiOjIzNDU2NywianRpIjoiZGUxMmY0ZTY3MDY4NDI3ODg5ZjE1YWMyNzcwZGEwNTEifQ.aEoAYkSJjoWH1boshQAaTkf8G3yn0kapko6HFRt7Rh4\"}' \\ http://localhost:8000/api/token/refresh/ ... {\"access\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX3BrIjoxLCJ0b2tlbl90eXBlIjoiYWNjZX...\", \"refresh\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX3BrIjoxLCJ0b2tlbl90eXBlIjoicmVm...\"}","title":"Usage"},{"location":"getting_started/#cryptographic-dependencies-optional","text":"If you are planning on encoding or decoding tokens using certain digital signature algorithms (i.e. RSA and ECDSA; visit PyJWT for other algorithms), you will need to install the cryptography_ library. This can be installed explicitly, or as a required extra in the django-ninja-jwt requirement: pip install django - ninja - jwt [ crypto ] The django-ninja-jwt[crypto] format is recommended in requirement files in projects using Ninja JWT , as a separate cryptography requirement line may later be mistaken for an unused requirement and removed. cryptography","title":"Cryptographic Dependencies (Optional)"},{"location":"settings/","text":"Some of Ninja JWT's behavior can be customized through settings variables in settings.py : # Django project settings.py from datetime import timedelta from django.conf import settings ... NINJA_JWT = { 'ACCESS_TOKEN_LIFETIME' : timedelta ( minutes = 5 ), 'REFRESH_TOKEN_LIFETIME' : timedelta ( days = 1 ), 'ROTATE_REFRESH_TOKENS' : False , 'BLACKLIST_AFTER_ROTATION' : False , 'UPDATE_LAST_LOGIN' : False , 'ALGORITHM' : 'HS256' , 'SIGNING_KEY' : settings . SECRET_KEY , 'VERIFYING_KEY' : None , 'AUDIENCE' : None , 'ISSUER' : None , 'JWK_URL' : None , 'LEEWAY' : 0 , 'USER_ID_FIELD' : 'id' , 'USER_ID_CLAIM' : 'user_id' , 'USER_AUTHENTICATION_RULE' : 'ninja_jwt.authentication.default_user_authentication_rule' , 'AUTH_TOKEN_CLASSES' : ( 'ninja_jwt.tokens.AccessToken' ,), 'TOKEN_TYPE_CLAIM' : 'token_type' , 'TOKEN_USER_CLASS' : 'ninja_jwt.models.TokenUser' , 'JTI_CLAIM' : 'jti' , 'SLIDING_TOKEN_REFRESH_EXP_CLAIM' : 'refresh_exp' , 'SLIDING_TOKEN_LIFETIME' : timedelta ( minutes = 5 ), 'SLIDING_TOKEN_REFRESH_LIFETIME' : timedelta ( days = 1 ), # For Controller Schemas # FOR OBTAIN PAIR 'TOKEN_OBTAIN_PAIR_INPUT_SCHEMA' : \"ninja_jwt.schema.TokenObtainPairInputSchema\" , 'TOKEN_OBTAIN_PAIR_REFRESH_INPUT_SCHEMA' : \"ninja_jwt.schema.TokenRefreshInputSchema\" , # FOR SLIDING TOKEN 'TOKEN_OBTAIN_SLIDING_INPUT_SCHEMA' : \"ninja_jwt.schema.TokenObtainSlidingInputSchema\" , 'TOKEN_OBTAIN_SLIDING_REFRESH_INPUT_SCHEMA' : \"ninja_jwt.schema.TokenRefreshSlidingInputSchema\" , 'TOKEN_BLACKLIST_INPUT_SCHEMA' : \"ninja_jwt.schema.TokenBlacklistInputSchema\" , 'TOKEN_VERIFY_INPUT_SCHEMA' : \"ninja_jwt.schema.TokenVerifyInputSchema\" , } Above, the default values for these settings are shown. ACCESS_TOKEN_LIFETIME A datetime.timedelta object which specifies how long access tokens are valid. This timedelta value is added to the current UTC time during token generation to obtain the token's default exp claim value. REFRESH_TOKEN_LIFETIME A datetime.timedelta object which specifies how long refresh tokens are valid. This timedelta value is added to the current UTC time during token generation to obtain the token's default exp claim value. BLACKLIST_AFTER_ROTATION When set to True , causes refresh tokens submitted to the TokenRefreshView to be added to the blacklist if the blacklist app is in use and the ROTATE_REFRESH_TOKENS setting is set to True . You need to add 'ninja_jwt.token_blacklist', to your INSTALLED_APPS in the settings file to use this setting. Learn more about /blacklist_app {.interpreted-text role=\"doc\"}. UPDATE_LAST_LOGIN When set to True , last_login field in the auth_user table is updated upon login (TokenObtainPairView). Warning : Updating last_login will dramatically increase the number of database transactions . People abusing the views could slow the server and this could be a security vulnerability . If you really want this , throttle the endpoint with DRF at the very least . ALGORITHM The algorithm from the PyJWT library which will be used to perform signing/verification operations on tokens. To use symmetric HMAC signing and verification, the following algorithms may be used: 'HS256' , 'HS384' , 'HS512' . When an HMAC algorithm is chosen, the SIGNING_KEY setting will be used as both the signing key and the verifying key. In that case, the VERIFYING_KEY setting will be ignored. To use asymmetric RSA signing and verification, the following algorithms may be used: 'RS256' , 'RS384' , 'RS512' . When an RSA algorithm is chosen, the SIGNING_KEY setting must be set to a string that contains an RSA private key. Likewise, the VERIFYING_KEY setting must be set to a string that contains an RSA public key. SIGNING_KEY The signing key that is used to sign the content of generated tokens. For HMAC signing, this should be a random string with at least as many bits of data as is required by the signing protocol. For RSA signing, this should be a string that contains an RSA private key that is 2048 bits or longer. Since Simple JWT defaults to using 256-bit HMAC signing, the SIGNING_KEY setting defaults to the value of the SECRET_KEY setting for your django project. Although this is the most reasonable default that Simple JWT can provide, it is recommended that developers change this setting to a value that is independent from the django project secret key. This will make changing the signing key used for tokens easier in the event that it is compromised. VERIFYING_KEY The verifying key which is used to verify the content of generated tokens. If an HMAC algorithm has been specified by the ALGORITHM setting, the VERIFYING_KEY setting will be ignored and the value of the SIGNING_KEY setting will be used. If an RSA algorithm has been specified by the ALGORITHM setting, the VERIFYING_KEY setting must be set to a string that contains an RSA public key. AUDIENCE The audience claim to be included in generated tokens and/or validated in decoded tokens. When set to None , this field is excluded from tokens and is not validated. ISSUER The issuer claim to be included in generated tokens and/or validated in decoded tokens. When set to None , this field is excluded from tokens and is not validated. JWK_URL The JWK_URL is used to dynamically resolve the public keys needed to verify the signing of tokens. When using Auth0 for example you might set this to 'https://yourdomain.auth0.com/.well-known/jwks.json'. When set to None , this field is excluded from the token backend and is not used during validation. LEEWAY Leeway is used to give some margin to the expiration time. This can be an integer for seconds or a datetime.timedelta . Please reference https://pyjwt.readthedocs.io/en/latest/usage.html#expiration-time-claim-exp for more information. AUTH_HEADER_TYPES The authorization header type(s) that will be accepted for views that require authentication. For example, a value of 'Bearer' means that views requiring authentication would look for a header with the following format: Authorization: Bearer <token> . This setting may also contain a list or tuple of possible header types (e.g. ('Bearer', 'JWT') ). If a list or tuple is used in this way, and authentication fails, the first item in the collection will be used to build the \"WWW-Authenticate\" header in the response. AUTH_HEADER_NAME The authorization header name to be used for authentication. The default is HTTP_AUTHORIZATION which will accept the Authorization header in the request. For example, if you'd like to use X_Access_Token in the header of your requests please specify the AUTH_HEADER_NAME to be HTTP_X_ACCESS_TOKEN in your settings. USER_ID_FIELD The database field from the user model that will be included in generated tokens to identify users. It is recommended that the value of this setting specifies a field that does not normally change once its initial value is chosen. For example, specifying a \"username\" or \"email\" field would be a poor choice since an account's username or email might change depending on how account management in a given service is designed. This could allow a new account to be created with an old username while an existing token is still valid which uses that username as a user identifier. USER_ID_CLAIM The claim in generated tokens which will be used to store user identifiers. For example, a setting value of 'user_id' would mean generated tokens include a \"user_id\" claim that contains the user's identifier. USER_AUTHENTICATION_RULE Callable to determine if the user is permitted to authenticate. This rule is applied after a valid token is processed. The user object is passed to the callable as an argument. The default rule is to check that the is_active flag is still True . The callable must return a boolean, True if authorized, False otherwise resulting in a 401 status code. AUTH_TOKEN_CLASSES A list of dot paths to classes that specify the types of token that are allowed to prove authentication. More about this in the \"Token types\" section below. TOKEN_TYPE_CLAIM The claim name that is used to store a token's type. More about this in the \"Token types\" section below. JTI_CLAIM The claim name that is used to store a token's unique identifier. This identifier is used to identify revoked tokens in the blacklist app. It may be necessary in some cases to use another claim besides the default \"jti\" claim to store such a value. TOKEN_USER_CLASS A stateless user object which is backed by a validated token. Used only for the JWTStatelessUserAuthentication authentication backend. The value is a dotted path to your subclass of ninja_jwt.models.TokenUser , which also is the default. SLIDING_TOKEN_LIFETIME A datetime.timedelta object which specifies how long sliding tokens are valid to prove authentication. This timedelta value is added to the current UTC time during token generation to obtain the token's default \"exp\" claim value. More about this in the \"Sliding tokens\" section below. SLIDING_TOKEN_REFRESH_LIFETIME A datetime.timedelta object which specifies how long sliding tokens are valid to be refreshed. This timedelta value is added to the current UTC time during token generation to obtain the token's default \"exp\" claim value. More about this in the \"Sliding tokens\" section below. SLIDING_TOKEN_REFRESH_EXP_CLAIM The claim name that is used to store the expiration time of a sliding token's refresh period. More about this in the \"Sliding tokens\" section below.","title":"Settings"},{"location":"settings/#access_token_lifetime","text":"A datetime.timedelta object which specifies how long access tokens are valid. This timedelta value is added to the current UTC time during token generation to obtain the token's default exp claim value.","title":"ACCESS_TOKEN_LIFETIME"},{"location":"settings/#refresh_token_lifetime","text":"A datetime.timedelta object which specifies how long refresh tokens are valid. This timedelta value is added to the current UTC time during token generation to obtain the token's default exp claim value.","title":"REFRESH_TOKEN_LIFETIME"},{"location":"settings/#blacklist_after_rotation","text":"When set to True , causes refresh tokens submitted to the TokenRefreshView to be added to the blacklist if the blacklist app is in use and the ROTATE_REFRESH_TOKENS setting is set to True . You need to add 'ninja_jwt.token_blacklist', to your INSTALLED_APPS in the settings file to use this setting. Learn more about /blacklist_app {.interpreted-text role=\"doc\"}.","title":"BLACKLIST_AFTER_ROTATION"},{"location":"settings/#update_last_login","text":"When set to True , last_login field in the auth_user table is updated upon login (TokenObtainPairView). Warning : Updating last_login will dramatically increase the number of database transactions . People abusing the views could slow the server and this could be a security vulnerability . If you really want this , throttle the endpoint with DRF at the very least .","title":"UPDATE_LAST_LOGIN"},{"location":"settings/#algorithm","text":"The algorithm from the PyJWT library which will be used to perform signing/verification operations on tokens. To use symmetric HMAC signing and verification, the following algorithms may be used: 'HS256' , 'HS384' , 'HS512' . When an HMAC algorithm is chosen, the SIGNING_KEY setting will be used as both the signing key and the verifying key. In that case, the VERIFYING_KEY setting will be ignored. To use asymmetric RSA signing and verification, the following algorithms may be used: 'RS256' , 'RS384' , 'RS512' . When an RSA algorithm is chosen, the SIGNING_KEY setting must be set to a string that contains an RSA private key. Likewise, the VERIFYING_KEY setting must be set to a string that contains an RSA public key.","title":"ALGORITHM"},{"location":"settings/#signing_key","text":"The signing key that is used to sign the content of generated tokens. For HMAC signing, this should be a random string with at least as many bits of data as is required by the signing protocol. For RSA signing, this should be a string that contains an RSA private key that is 2048 bits or longer. Since Simple JWT defaults to using 256-bit HMAC signing, the SIGNING_KEY setting defaults to the value of the SECRET_KEY setting for your django project. Although this is the most reasonable default that Simple JWT can provide, it is recommended that developers change this setting to a value that is independent from the django project secret key. This will make changing the signing key used for tokens easier in the event that it is compromised.","title":"SIGNING_KEY"},{"location":"settings/#verifying_key","text":"The verifying key which is used to verify the content of generated tokens. If an HMAC algorithm has been specified by the ALGORITHM setting, the VERIFYING_KEY setting will be ignored and the value of the SIGNING_KEY setting will be used. If an RSA algorithm has been specified by the ALGORITHM setting, the VERIFYING_KEY setting must be set to a string that contains an RSA public key.","title":"VERIFYING_KEY"},{"location":"settings/#audience","text":"The audience claim to be included in generated tokens and/or validated in decoded tokens. When set to None , this field is excluded from tokens and is not validated.","title":"AUDIENCE"},{"location":"settings/#issuer","text":"The issuer claim to be included in generated tokens and/or validated in decoded tokens. When set to None , this field is excluded from tokens and is not validated.","title":"ISSUER"},{"location":"settings/#jwk_url","text":"The JWK_URL is used to dynamically resolve the public keys needed to verify the signing of tokens. When using Auth0 for example you might set this to 'https://yourdomain.auth0.com/.well-known/jwks.json'. When set to None , this field is excluded from the token backend and is not used during validation.","title":"JWK_URL"},{"location":"settings/#leeway","text":"Leeway is used to give some margin to the expiration time. This can be an integer for seconds or a datetime.timedelta . Please reference https://pyjwt.readthedocs.io/en/latest/usage.html#expiration-time-claim-exp for more information.","title":"LEEWAY"},{"location":"settings/#auth_header_types","text":"The authorization header type(s) that will be accepted for views that require authentication. For example, a value of 'Bearer' means that views requiring authentication would look for a header with the following format: Authorization: Bearer <token> . This setting may also contain a list or tuple of possible header types (e.g. ('Bearer', 'JWT') ). If a list or tuple is used in this way, and authentication fails, the first item in the collection will be used to build the \"WWW-Authenticate\" header in the response.","title":"AUTH_HEADER_TYPES"},{"location":"settings/#auth_header_name","text":"The authorization header name to be used for authentication. The default is HTTP_AUTHORIZATION which will accept the Authorization header in the request. For example, if you'd like to use X_Access_Token in the header of your requests please specify the AUTH_HEADER_NAME to be HTTP_X_ACCESS_TOKEN in your settings.","title":"AUTH_HEADER_NAME"},{"location":"settings/#user_id_field","text":"The database field from the user model that will be included in generated tokens to identify users. It is recommended that the value of this setting specifies a field that does not normally change once its initial value is chosen. For example, specifying a \"username\" or \"email\" field would be a poor choice since an account's username or email might change depending on how account management in a given service is designed. This could allow a new account to be created with an old username while an existing token is still valid which uses that username as a user identifier.","title":"USER_ID_FIELD"},{"location":"settings/#user_id_claim","text":"The claim in generated tokens which will be used to store user identifiers. For example, a setting value of 'user_id' would mean generated tokens include a \"user_id\" claim that contains the user's identifier.","title":"USER_ID_CLAIM"},{"location":"settings/#user_authentication_rule","text":"Callable to determine if the user is permitted to authenticate. This rule is applied after a valid token is processed. The user object is passed to the callable as an argument. The default rule is to check that the is_active flag is still True . The callable must return a boolean, True if authorized, False otherwise resulting in a 401 status code.","title":"USER_AUTHENTICATION_RULE"},{"location":"settings/#auth_token_classes","text":"A list of dot paths to classes that specify the types of token that are allowed to prove authentication. More about this in the \"Token types\" section below.","title":"AUTH_TOKEN_CLASSES"},{"location":"settings/#token_type_claim","text":"The claim name that is used to store a token's type. More about this in the \"Token types\" section below.","title":"TOKEN_TYPE_CLAIM"},{"location":"settings/#jti_claim","text":"The claim name that is used to store a token's unique identifier. This identifier is used to identify revoked tokens in the blacklist app. It may be necessary in some cases to use another claim besides the default \"jti\" claim to store such a value.","title":"JTI_CLAIM"},{"location":"settings/#token_user_class","text":"A stateless user object which is backed by a validated token. Used only for the JWTStatelessUserAuthentication authentication backend. The value is a dotted path to your subclass of ninja_jwt.models.TokenUser , which also is the default.","title":"TOKEN_USER_CLASS"},{"location":"settings/#sliding_token_lifetime","text":"A datetime.timedelta object which specifies how long sliding tokens are valid to prove authentication. This timedelta value is added to the current UTC time during token generation to obtain the token's default \"exp\" claim value. More about this in the \"Sliding tokens\" section below.","title":"SLIDING_TOKEN_LIFETIME"},{"location":"settings/#sliding_token_refresh_lifetime","text":"A datetime.timedelta object which specifies how long sliding tokens are valid to be refreshed. This timedelta value is added to the current UTC time during token generation to obtain the token's default \"exp\" claim value. More about this in the \"Sliding tokens\" section below.","title":"SLIDING_TOKEN_REFRESH_LIFETIME"},{"location":"settings/#sliding_token_refresh_exp_claim","text":"The claim name that is used to store the expiration time of a sliding token's refresh period. More about this in the \"Sliding tokens\" section below.","title":"SLIDING_TOKEN_REFRESH_EXP_CLAIM"},{"location":"token_types/","text":"Ninja JWT provides two different token types that can be used to prove authentication. In a token's payload, its type can be identified by the value of its token type claim, which is token_type by default. This may have a value of access , sliding , or refresh however refresh tokens are not considered valid for authentication at this time. The claim name used to store the type can be customized by changing the TOKEN_TYPE_CLAIM setting. By default, Ninja JWT expects an access token to prove authentication. The allowed auth token types are determined by the value of the AUTH_TOKEN_CLASSES setting. This setting contains a list of dot paths to token classes. It includes the 'ninja_jwt.tokens.AccessToken' dot path by default but may also include the 'ninja_jwt.tokens.SlidingToken' dot path. Either or both of those dot paths may be present in the list of auth token classes. If they are both present, then both of those token types may be used to prove authentication. Sliding tokens Sliding tokens offer a more convenient experience to users of tokens with the trade-offs of being less secure and, in the case that the blacklist app is being used, less performant. A sliding token is one that contains both an expiration claim and a refresh expiration claim. As long as the timestamp in a sliding token\\'s expiration claim has not passed, it can be used to prove authentication. Additionally, as long as the timestamp in its refresh expiration claim has not passed, it may also be submitted to a refresh view to get another copy of itself with a renewed expiration claim. If you want to use sliding tokens, change the AUTH_TOKEN_CLASSES setting to ('ninja_jwt.tokens.SlidingToken',) . (Alternatively, the AUTH_TOKEN_CLASSES setting may include dot paths to both the AccessToken and SlidingToken token classes in the ninja_jwt.tokens module if you want to allow both token types to be used for authentication.) Also, register NinjaJWTSlidingController to the api : from ninja_jwt.controller import NinjaJWTSlidingController from ninja_extra import NinjaExtraAPI api = NinjaExtraAPI () api . register_controllers ( NinjaJWTSlidingController ) Be aware that, if you are using the blacklist app, Ninja JWT will validate all sliding tokens against the blacklist for each authenticated request. This will reduce the performance of authenticated API views.","title":"Token Types"},{"location":"token_types/#sliding-tokens","text":"Sliding tokens offer a more convenient experience to users of tokens with the trade-offs of being less secure and, in the case that the blacklist app is being used, less performant. A sliding token is one that contains both an expiration claim and a refresh expiration claim. As long as the timestamp in a sliding token\\'s expiration claim has not passed, it can be used to prove authentication. Additionally, as long as the timestamp in its refresh expiration claim has not passed, it may also be submitted to a refresh view to get another copy of itself with a renewed expiration claim. If you want to use sliding tokens, change the AUTH_TOKEN_CLASSES setting to ('ninja_jwt.tokens.SlidingToken',) . (Alternatively, the AUTH_TOKEN_CLASSES setting may include dot paths to both the AccessToken and SlidingToken token classes in the ninja_jwt.tokens module if you want to allow both token types to be used for authentication.) Also, register NinjaJWTSlidingController to the api : from ninja_jwt.controller import NinjaJWTSlidingController from ninja_extra import NinjaExtraAPI api = NinjaExtraAPI () api . register_controllers ( NinjaJWTSlidingController ) Be aware that, if you are using the blacklist app, Ninja JWT will validate all sliding tokens against the blacklist for each authenticated request. This will reduce the performance of authenticated API views.","title":"Sliding tokens"}]}